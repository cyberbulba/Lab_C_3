#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

struct list
{
	int inf;
	struct list* next;
};

//ввод списка
struct list* input_list(struct list* start)
{
	struct list* cur, * end;
	cur = end = NULL;
	int ind;
	char buf;

	while (1)
	{
		cur = (struct list*)malloc(sizeof(struct list));
		cur->next = NULL;
		ind = scanf("%d", &cur->inf);
		if (ind == 0)
		{
			return NULL;
		}
		if (start == NULL)
		{
			start = cur;
			end = cur;
		}
		else
		{
			end->next = cur;
			end = cur;
		}
		scanf("%c", &buf);
		if (buf == '.')
			break;
	}
	return start;
}

//очистка памяти
void clear_memory(struct list** start)
{
	struct list* cur = *start;
	while (cur != NULL)
	{
		*start = cur->next;
		free(cur);
		cur = *start;
	}
	*start = NULL;
	return;
}

//удаление элементов
void remove_elements_from_a_to_b_to_new_struct(struct list** start, struct list** start_new, int a, int b)
{
	struct list* cur, * last;
	struct list *end_new;
	cur = last = *start;
	end_new = *start_new;
	while (cur != NULL)
	{
		if (cur->inf >= a && cur->inf <= b)
		{
			if (cur == *start)         //если элемент который надо переместить стоит на первом месте
			{
				if (*start_new == NULL)      //если до этого в новом списке не было элементов 
				{
					*start_new = *start;     //указатель на начало нвого списка
					end_new = *start;		 //указатель на конец нового списка
					*start = (*start)->next; //передвигаем начало старого списка
					last = cur;				 //указатель на предыдущий ставим на текущий
					cur = cur->next;		 //передвигаем текущий
					end_new->next = NULL;    //зануляем последний элемент нового списка
				}
				else                        //если до этого в списке были элементы
				{
					end_new->next = *start;  //делаем элемент концом нового списка
					end_new = *start;        //указатель на конец нового списка
					*start = (*start)->next; //передвигаем начало старого списка
					last = cur;              //указатель на предыдущий ставим на текущий
					cur = cur->next;         //передвигаем текущий
					end_new->next = NULL;    //зануляем последний элемент нового списка

				}
			}
			else                       //если элемент который надо переместить стоит в середине или в конце
			{
				if (*start_new == NULL) //если в новом списке ещё нет
				{
					*start_new = cur;   //текущий делаем первым во втором списке
					end_new = cur;      //текущий делаем последним во втором списке
					last->next = cur->next; //переставляем указатель через элемент который надо поместить в новый список
					cur = cur->next; //двигаем текущий
					end_new->next = NULL; //зануляем последний элемент нового списка
				}
				else                        //если элементы были
				{
					end_new->next = cur; //делаем текущий концом нового списка
					end_new = cur; //текущий делаем последним во втором списке
					last->next = cur->next; //переставляем указатель через элемент который надо поместить в новый список
					cur = cur->next; //двигаем текущий
					end_new->next = NULL; //зануляем последний элемент нового списка
				}
			}
		}
		else
		{
			last = cur; //двигаем предыдущий
			cur = cur->next; //двигаем текущий
		}						   
	}
	return;
}

void print_list(struct list** start)
{
	struct list* cur = *start;
	for (cur = *start;cur != NULL;cur = cur->next)
	{
		printf("%d ", cur->inf);
	}
	return;
}

int main()
{
	int a, b;
	struct list* start, *start_new;
	start = start_new = NULL;
	
	printf("Input start list:\n");
	start = input_list(start);

	if (start == NULL)
	{
		printf("NULL");
		return 0;
	}

	printf("Input A:\n");
	scanf("%d", &a);
	
	printf("Input B:\n");
	scanf("%d", &b);

	remove_elements_from_a_to_b_to_new_struct(&start, &start_new, a, b);

	if (start == NULL)
	{
		printf("NULL");
		return 0;
	}

	printf("Old list:\n");
	print_list(&start);
	
	if (start_new == NULL)
	{
		printf("New list is NULL.");
		return 0;
	}
	
	printf("\nNew list:\n");
	print_list(&start_new);
	clear_memory(&start);

	return 0;
}
